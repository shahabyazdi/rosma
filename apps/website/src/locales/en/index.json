{
  "common": {
    "en": "English",
    "fa": "Persian"
  },
  "home": {
    "description": [
      "Rosma is a lightweight and easy-to-use global state management library designed for React applications. It offers three essential APIs for managing your app's state: `observer`, `useObserver`, and `withState`.",
      "Unlike other state management libraries, Rosma is incredibly easy to set up and use. it is written in such a way that it does not require an initial and sometimes complicated setup. Simply install it via npm (`npm i rosma`), and you're good to go.",
      "One of the key advantages of Rosma is its simple naming convention for variables and setter methods. To set a setter method for a variable, all you need to do is prepend the variable name with the `set` and destructure it from the state management. For instance, to set a value for the `count` variable, you would name the corresponding setter method `setCount`.",
      "Rosma's `observer` API allows you to declare global state variables and update them from anywhere in your application. `useObserver` provides a simple way to consume these global state variables in your functional components, while `withState` is a higher-order component that enables based components to access the global state.",
      "Overall, Rosma is a powerful yet straightforward state management library that simplifies the process of managing your app's state. Try it out today and see how it can improve your development workflow."
    ],
    "keywords": [
      [
        "React",
        "state management",
        "global state",
        "observer",
        "useObserver",
        "withState",
        "lightweight",
        "user-friendly",
        "easy-to-user",
        "npm",
        "naming convention",
        "setter methods",
        "functional components",
        "development workflow"
      ]
    ]
  },
  "installation": {
    "howto": "To install Rosma, you can use either `npm` or `yarn`. simply run the following command in your project directory:",
    "description": [
      "This will download and install the latest version of the package from the npm registry.",
      "Once installed, you can import the three main APIs (`observer`, `useObserver`, and `withState`) from the `rosma` package and start managing your application state.",
      "It's important to note that Rosma doesn't require any additional setup or configuration, making it an ideal choice for developers looking for a simple and lightweight state management solution."
    ],
    "keywords": [
      [
        "React",
        "state management",
        "installation",
        "npm",
        "global state",
        "observer",
        "useObserver",
        "withState",
        "lightweight",
        "simple",
        "configuration",
        "naming convention",
        "setter methods",
        "functional components",
        "class-based components",
        "development process"
      ]
    ]
  },
  "usage": {
    "counter": {
      "description": "The `Counter` component is a simple example that demonstrates how to use Rosma to manage the state in your React application. In this example, we use the `useObserver` hook to create a global state variable called `count`, which is initially set to `0`, and a setter method called `setCount`.",
      "alt": "You can also use the same with `whitState` HOC :",
      "explain": [
        "In the example above, we're using the `useObserver` hook to create a global state variable called `count` and its corresponding setter method called `setCount`. The initial value of the `count` is set to `0`.",
        "To update the `count` variable, we simply call its corresponding setter method `setCount` with the new value. In this case, we're incrementing the `count` value by `1` each time the button is clicked."
      ]
    },
    "order": {
      "description": "It's worth noting that the order in which the variables are destructured from the `useObserver` hook doesn't matter. Rosma will automatically assign the correct values to each variable based on their names.",
      "explain": "In the example above, we've destructured the `setCount` and `count` variables in the opposite order from the previous example, and Rosma is still able to assign the correct values to each variable."
    },
    "caseinsensitive": {
      "description": "It's also important to note that all variables names in the state are case-insensitive. This means that you can use any combination of uppercase and lowercase letters when destructuring your variables.",
      "explain": [
        "In the example above, we've taken the `count` variable as `CouNt` and its corresponding setter method as `setcOunT`, both with mixed case letters. Rosma is still able to assign the correct values to each variable based on their names.",
        "By using the `useObserver` hook along with its corresponding setter method naming convention, Rosma makes it easy to manage global state variables in your React application. Give it a try and see how it can simplify your state management process."
      ]
    },
    "keywords": [
      [
        "React",
        "state management",
        "Rosma",
        "useObserver",
        "global state",
        "variable names",
        "destructuring",
        "setter methods",
        "incrementing",
        "case-insensitive",
        "naming convention"
      ]
    ]
  },
  "multipleDestructuring": {
    "description": [
      "In Rosma, you can easily destructure multiple variables at once from the observer object returned by the `useObserver` hook. This can make your code more concise and easier to read.",
      "Here's an example:"
    ],
    "explain": "In the above code, we are destructuring `count`, `setCount`, `count1`, and `setCount1` variables from the `useObserver` hook. This allows us to directly use these variables in our component without needing to access them through the observer object.",
    "keywords": [
      [
        "Rosma",
        "observer",
        "useObserver",
        "Destructuring variables",
        "State management",
        "Front-end development",
        "Code optimization",
        "Code readability",
        "React hooks",
        "Multiple variables",
        "Variable assignment"
      ]
    ]
  },
  "initialValues": {
    "description": "By default, all the destructured variables from `useObserver` have the same initial value. To set different initial values for each variable, you have a couple of options:",
    "separate": {
      "explain": "In the above code, we have created two separate useObserver hooks to define different initial values for count and count1."
    },
    "once": {
      "description": "If you want to set initial values for all the destructured variables at once, you can use the `observer.set` method before calling the `useObserver` hook:",
      "explain": [
        "In the above code, we are setting the initial values for `count` and `count1` using the `observer.set` before calling the `useObserver` hook. This allows us to destructure the variables without passing any arguments to the `useObserver` hook, and the variables will have the initial values we specified using the `observer.set`.",
        "Overall, destructuring multiple variables from `useObserver` can help make your code more concise and readable, and setting different initial values for each variable is easy using the methods described above."
      ]
    },
    "keywords": [
      [
        "Rosma",
        "useObserver",
        "Destructuring variables",
        "Initial values",
        "Observer.set",
        "React hooks",
        "Code optimization",
        "Code readability",
        "State management",
        "Front-end development"
      ]
    ]
  },
  "observer": {
    "description": [
      "Observer is a tool that allows you to declare global state variables and update them from anywhere in your application.",
      "In addition to updating state values, you can also observe them using Observer to be notified when they change.",
      "By default, Rosma uses a single instance of the Observer class. However, you can use multiple instances of the Observer class to better manage your project. This will be explained in the next sections.",
      "The Observer class provides several methods, which are listed below:",
      "- [observer.get](#observerget) \n- [observer.set](#observerset) \n- [observer.state](#observerstate) \n- [observer.isValid](#observerisvalid) \n- [observer.subscribe](#observersubscribe)"
    ],
    "get": {
      "description": "The `observer.get` method is used to retrieve values from the state. You can use this method to get one or more values simultaneously.",
      "singleValue": [
        "To retrieve a single value from the state, you must pass the key of the variable as an argument to the `get` method.",
        "For example, suppose the value of the `foo` in the state is equal to `'bar'`. In this case, you can retrieve the value of the `foo` and assign it to a variable as follows:"
      ],
      "multipleValues": [
        "If you want to retrieve more than one value from the state, you must pass the desired keys as an array to the `get` method. In this case, the value returned from the `get` method is an object.",
        "For example, suppose our state contains values of `foo` equal to `'bar'` and `baz` equal to `'qux'`. To retrieve the values of `foo` and `baz` at the same time, you can use the following code:"
      ],
      "explain": "You can also destructure the returned object to assign each value to a separate variable, like this:"
    },
    "set": {
      "description": [
        "The `set` method is used to change or add one or more values in the state. When a value in the state is changed using the `set` method, all components that use that value will be rerendered. However, it's also possible to change a value silently, without triggering a rerender of the components that use it.",
        "_**Note** that if you set a value silently, and a component using that value is later rerendered for any other reasons, the new value will be received from the state._"
      ],
      "demo": [
        "In this example, the `DisplayTime` component retrieves the `time` value from the `Observer` state using `useObserver` and displays it in a paragraph element.",
        "The component also includes three buttons that allow the user to update the `time` value in different ways. The first button calls the `setTime` method to update the value using the `useObserver` hook. The second button calls the `observer.set` method to update the value directly in the `Observer` state. The third button calls the `observer.set` method with the `silent` option to update the value silently, without triggering a rerender of any components that use the `time` value."
      ]
    },
    "example": {
      "description": [
        "This code is a simple example of using global state management with the Observer tool. It allows the user to open and close modal components and displays them in the app."
      ],
      "app": "The `App` component is the entry point of the application. It contains a button that triggers the opening of a modal and renders the `Modals` component that shows all open modals. The `newModal` function is imported from `actions.ts` to handle the opening of the new modal.",
      "modal": "The `Modals` component uses the `useObserver` hook to get the `modals` array from the state, which holds the data for each open modal. The `map` function is used to render a `Modal` component for each open modal. The `Modal` component is responsible for rendering the modal component with its `title`, `body`, and `close` button.",
      "actions": "The `actions` file exports two functions: `newModal` and `closeModal`. Both of these functions use the `observer` instance provided by the Rosma library to get and set the `modals` array in the global state. The `newModal` function creates a new modal object with a unique `id`, `title`, and `body` and adds it to the `modals` array. The `closeModal` function filters out the modal with the given `id` from the `modals` array."
    },
    "state": {
      "description": [
        "Returns the current value of the state.",
        "Note that mutating the state using `observer.state` does not re-render the components or trigger listeners.  "
      ]
    },
    "isValid": {
      "description": [
        "`observer.get` checks whether a given `key` exists in the state or not. it gets a string as the `key` and determines whether that variable is defined in the state or not."
      ]
    },
    "subscribe": {
      "description": [
        "The `subscribe` method is utilized to monitor changes in one or more variables in the `state`. This method requires two input parameters:",
        "1. The desired `key` or `keys` that you want to observe.",
        "2. A `listener` that will execute when the desired `key` or `keys` have changed.",
        "The method returns an `unsubscribe` function, allowing you to stop listening to state changes when needed. It can be used within `useEffect` or outside of your React component, depending on your needs. If you need to monitor the changes of multiple variables at the same time, you can provide them as an **`array`** and pass the as the first parameter. However, note that in this case, the desired values will be passed to the listener function as an **`object`**.",
        "We will talk more about subscribe in the next sections."
      ],
      "demo": [
        "This code imports the `observer` and `useObserver` from the `rosma` library. It then `subscribes` to changes of a variable named myVar by calling `observer.subscribe` and passing in the name of the variable and a listener function that will be called whenever the variable changes.",
        "The `ObserverTest` component uses `useObserver` to get the `setMyVar` function, which can be called to update the value of `myVar`. The component renders a button that, when clicked, calls `setMyVar` with a new date object as its argument. When `myVar` changes, the `listener` function is called and an alert is displayed with the updated value of `myVar`.",
        "If the user clicks on the `unsubscribe` button. The `unsubscribe` method is executed and the `listener` function is no longer called with the `myVar` changes."
      ]
    },
    "keywords": [
      [
        "Observer",
        "global state variables",
        "update state",
        "observe state",
        "multiple instances",
        "observer.get",
        "observer.set",
        "observer.isValid",
        "observer.subscribe",
        "retrieve values",
        "get single value",
        "get multiple values",
        "change or add values",
        "silently",
        "Demo",
        "modals example",
        "app.tsx",
        "modals.tsx"
      ]
    ]
  },
  "multipleObservers": {
    "description": [
      "If you have a large-scale application, or you want to manage different the state of each part of your app separately, you can create multiple instances of the Observer class for this purpose.",
      "If you to make instance of the `Observer` class, you must import the `Observer` from `rosma` and create an instance of it using the `new` keyword."
    ],
    "initialValues": "Note that you can pass the initial values of the state to the constructor of the observer class.",
    "example": "Also, in order for the useObserver hook to use your personal observer, you can send your own observer to it.",
    "useObserver": {
      "description": "In order to not repeat passing the `observer` to the `useObserver` hook throughout your app, you can export your personal hook once and import it everywhere in the app, as in the example below.",
      "explain": [
        "This example is demonstrating how to create and export multiple instances of the `Observer` class with different initial states, using the `new` keyword. Three instances of the `observer` are created with the names `UIObserver`, `authObserver`, and `dataObserver`. Each instance has a different initial state, which is defined using objects.",
        "In addition to creating the observers, we exports three functions, `useUIObserver()`, `useAuthObserver()`, and `useDataObserver()`, which use the `useObserver` hook to provide access to the respective observers throughout the application.",
        "This approach can help in managing the state of different parts of an application separately. By having separate observers, you can easily modify the state of a particular part of the app without affecting the state of the other parts."
      ]
    },
    "observers": {
      "description": "To keep your code clean, it is better to keep the observers for each part of your app in a separate file. For example, the above code can be placed in three separate files as shown below:",
      "note": "**Note:** This example is given in order to provide a **concept** of how to manage the state in an app. The parts provided above are for illustrative purposes. For instance, in the `data` section, it is advisable to use more specialized libraries for fetch and caching data, like `react-query`."
    },
    "keywords": [
      [
        "React",
        "rosma",
        "observer",
        "useObserver",
        "multiple observers",
        "custom useObserver"
      ]
    ]
  }
}
