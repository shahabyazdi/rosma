{
  "common": {
    "Rosma": "رُزما",
    "Next": "بعدی",
    "Previous": "قبلی",
    "Home": "خانه",
    "Installation": "نصب و راه اندازی",
    "en": "انگلیسی",
    "fa": "فارسی",
    "Keywords": "کلید واژه ها",
    "Usage": "استفاده",
    "Multiple destructuring": "گرفتن همزمان چندین متغیر",
    "Different initial values": "مقادیر اولیه متفاوت",
    "Observer": "کلاس مشاهده گر",
    "Multiple observers": "استفاده از چند مشاهده گر",
    "Subscribe for state changes": "نظارت بر تغییرات استیت"
  },
  "home": {
    "description": [
      "Rosma یک کتابخانه مدیریت  سراسری استیت کم حجم و با استفاده آسان است که برای کامپوننت های ری اکت طراحی شده است. رزما سه API ضروری برای مدیریت وضعیت برنامه به شما ارائه می دهد: `observer` ، `useObserver`، و `withState`.",
      "برخلاف سایر کتابخانه های مدیریت استیت، راه اندازی و استفاده از Rosma فوق العاده آسان است و به گونه ای نوشته شده است که نیازی به تنظیمات اولیه و گاه پیچیده ندارد. به سادگی آن را از طریق ان پی ام (`npm i rosma`) نصب کنید و بدون کانفیگ اضافه، استفاده از آن را شروع کنید.",
      "یکی از مزایای کلیدی Rosma، نامگذاری ساده آن برای متغیرها و متدهای ستر برای متغیر ها است. برای تعریف کردن یک ستر متد برای یک متغیر، تنها کاری که باید انجام دهید این است که قبل از نام متغیر یک `set` اضافه کنید و آن را استخراج کنید. به عنوان مثال، برای تنظیم یک مقدار برای متغیر `count`، باید ستر متد مربوطه را `setCount` نامگذاری کنید.",
      "ای پی ای `observer` در رزما به شما این امکان را می دهد که با آن متغیرهای استیت سراسری را تعریف کرده  و آنها را از هر جایی در برنامه خود فراخوانی یا بروزرسانی کنید. `useObserver` یک هوک ساده برای استفاده از متغیرهای موجود در استیت، در کامپوننت ها شما ارائه می‌کند، در حالی که `withState` یک higher order component است که کامپوننت های شما را به استیت سراسری متصل میکند.",
      "به طور کلی، Rosma یک کتابخانه مدیریت استیت قدرتمند و در عین حال ساده است که فرآیند مدیریت وضعیت برنامه شما را ساده می کند. امروز آن را امتحان کنید و ببینید که چگونه می تواند روند توسعه برنامه های شما را بهبود بخشد."
    ],
    "keywords": [
      [
        "ری اکت",
        "مدیریت استیت",
        "استیت سراسری",
        "مشاهده کننده",
        "useObserver",
        "withState",
        "lightweight",
        "نصب آسان",
        "کاربر پسند",
        "npm",
        "نامگذاری",
        "متد تنظیم استیت",
        "فانکشنال کامپوننت",
        "روند کار توسعه"
      ]
    ]
  },
  "installation": {
    "howto": "برای نصب Rosma می‌توانید از `npm` یا `yarn` استفاده کنید. به سادگی دستور زیر را در پوشه پروژه خود اجرا کنید:",
    "description": [
      "با این کار آخرین نسخه کتابخانه از رجیستری npm دانلود و نصب می شود.",
      "پس از نصب، می توانید سه API اصلی (`observer`، `useObserver` و `withState`) را از بسته `rosma` ایمپورت کرده و مدیریت استیت برنامه خود را شروع کنید.",
      "مهم است که توجه داشته باشید که Rosma به هیچ گونه تنظیمات یا پیکربندی اضافی نیاز ندارد، و آن را به یک انتخاب ایده آل برای توسعه دهندگانی تبدیل می کند که به دنبال راه حل مدیریت استیت ساده و آسان هستند."
    ],
    "keywords": [
      [
        "ری اکت",
        "مدیریت استیت",
        "نصب",
        "npm",
        "استیت سراسری",
        "observer",
        "useObserver",
        "withState",
        "کم حجم",
        "آسان",
        "تنظیمات",
        "قواعد نامگذاری",
        "کامپوننت",
        "روند توسعه"
      ]
    ]
  },
  "usage": {
    "counter": {
      "description": "کامپوننت `Counter` یک مثال ساده است که نحوه استفاده از Rosma را برای مدیریت استیت در برنامه React نشان می دهد. در این مثال از `useObserver` برای ایجاد یک متغیر سراسری به نام `count` با مقدار اولیه `۰` و یک متد setter به نام `setCount` استفاده می کنیم.",
      "alt": "میتوان همین مثال بالا را با استفاده از `withState` به صورت زیر بازنویسی کرد :",
      "explain": [
        "در مثال بالا، ما از هوک `useObserver`  برای ایجاد یک متغیر سراسری به نام `count`  استفاده کرده و متد تنظیم کننده مربوط به آن را `setCount`  نام گذاری می‌کنیم. مقدار اولیه `count` روی `۰`  تنظیم شده است.",
        "برای به‌روزرسانی متغیر `count`، به سادگی متد تنظیم‌کننده مربوطه آن  `setCount`  را با مقدار جدید صدا میزنیم. در این مورد، هر بار که روی دکمه کلیک می‌شود، مقدار `count`  را با `۱` جمع میکنیم."
      ]
    },
    "order": {
      "description": "شایان ذکر است که ترتیب گرفتن متغیرها از هوک `useObserver` مهم نیست. رزما به طور خودکار مقادیر صحیح را به هر متغیر بر اساس نام آنها اختصاص می دهد.",
      "explain": "در مثال بالا، ما متغیرهای `setCount` و `count` را به ترتیبی خلاف مثال قبلی دریافت کردیم و Rosma همچنان می‌تواند مقادیر صحیح را به هر متغیر اختصاص دهد."
    },
    "caseinsensitive": {
      "description": "همچنین مهم است که توجه داشته باشید که نام‌ همه متغیر ها در استیت به حروف بزرگ و کوچک حساس نیستند. این بدان معنی است که شما می توانید هر ترکیبی از حروف بزرگ و کوچک را درهنگام گرفتن متغیرهای خود از `useObserver`  استفاده کنید.",
      "explain": [
        "در مثال بالا، ما متغیر `count` را به عنوان `CouNt` و method  تنظیم کننده متناظر آن را به عنوان `setcOunT` نامگذاری کردیم، هر دو با حروف کوچک و بزرگ ترکیبی. رزما هنوز هم قادر است مقادیر صحیح را به هر متغیر بر اساس نام آنها اختصاص دهد."
      ]
    },
    "keywords": [
      [
        "ری اکت",
        "مدیریت استیت",
        "رُزما",
        "useObserver",
        "استیت سراسری",
        "نامگذاری مقادیر",
        "استخراج مقادیر",
        "متد تنظیم کننده",
        "حساس نبودن به حروف",
        "قواعد نامگذاری"
      ]
    ]
  },
  "multipleDestructuring": {
    "description": [
      "در Rosma، شما به راحتی می توانید چندین متغیر را به طور همزمان از هوک `useObserver` دریافت کنید. این می تواند کد شما را مختصرتر و خواناتر کند.",
      "به مثال زیر توجه کنید:"
    ],
    "explain": "در کد بالا، ما به طور همزمان متغیرهای `count1`، `setCount`، `count` و `setCount1` را از هوک `useObserver` دریافت کردیم. این به ما این امکان را می دهد که مستقیماً این متغیرها را در کامپوننت خود، بدون نیاز به دسترسی به `observer` استفاده کنیم.",
    "keywords": [
      [
        "رُزما",
        "observer",
        "useObserver",
        "دریافت مقادیر",
        "مدیریت استیت",
        "توسعه فرانت اند",
        "بهینه سازی کد",
        "خوانایی کد",
        "هوک ری اکت",
        "مقادیر چند گانه",
        "مقدار دهی متغیر"
      ]
    ]
  },
  "initialValues": {
    "description": "به‌طور پیش‌فرض، همه متغیرهای گرفته شده از `useObserver` مقادیر اولیه یکسانی دارند. برای تنظیم مقادیر اولیه متفاوت برای هر متغیر، میتونید از یکی از روش های زیر استفاده کنید:",
    "separate": {
      "explain": "در کد بالا، هوک `useObserver` را دوبار و به صورت جداگانه برای تعریف مقادیر اولیه مختلف برای `count` و `count1` استفاده کردیم."
    },
    "once": {
      "description": "اگر می خواهید مقادیر اولیه را برای همه متغیرها به طور همزمان تنظیم کنید، می توانید قبل از فراخوانی هوک `useObserver` آنها را مستقیما و با استفاده از متد `set`  موجود در `observer` استفاده کنید:",
      "explain": [
        "در کد بالا، قبل از فراخوانی هوک `useObserver` ، مقادیر اولیه `count` و `count1` را با استفاده از `observer.set` تنظیم می‌کنیم. این به ما امکان می‌دهد که متغیرها را بدون ارسال هیچونه آرگومان به هوک `useObserver` مقداردهی و استفاده کنیم، و آن متغیرها مقادیر اولیه‌ای را خواهند داشت که با استفاده از `observer.set` مشخص کردیم.",
        "به طور کلی، گرفتن چندین متغیر از `useObserver` می‌تواند به مختصر و خوانا تر شدن کد شما کمک کند، و تنظیم مقادیر اولیه متفاوت برای هر متغیر با استفاده از روش‌هایی که در بالا توضیح داده شد، آسان است."
      ]
    },
    "keywords": [
      [
        "رزما",
        "useObserver",
        "دریافت مقادیر",
        "مقادیر اولیه",
        "observer.set",
        "هوک های ری اکت",
        "بهینه سازی کد",
        "خوانایی کد",
        "مدیریت استیت",
        "برنامه نویسی فرانت اند"
      ]
    ]
  },
  "observer": {
    "description": [
      "Observer ابزاری است که به شما امکان می دهد متغیرهای استیت سراسری خود را مقداردهی کرده و آنها را از هر نقطه در برنامه خود به روز کنید.",
      "با استفاده از Observer، علاوه بر به روز رسانی مقادیر استیت، می توانید به تغییرات مقادیر گوش دهید تا در صورت تغییر آنها  از آن مطلع شوید.",
      "به طور پیش فرض، Rosma از یک نمونه از کلاس Observer استفاده می کند. با این حال، می توانید از چندین نمونه از کلاس Observer برای مدیریت بهتر پروژه خود استفاده کنید. در بخش های بعدی این موضوع توضیح داده خواهد شد.",
      "کلاس Observer چندین متد ارائه می دهد که در زیر لیست شده است:",
      "- [observer.get](#observerget) \n- [observer.set](#observerset) \n- [observer.state](#observerstate) \n- [observer.isValid](#observerisvalid) \n- [observer.subscribe](#observersubscribe)"
    ],
    "get": {
      "description": "متد `observer.get` برای دریافت مقادیر از استیت استفاده می شود. می توانید از این متد برای دریافت یک یا چند مقدار به طور همزمان استفاده کنید.",
      "singleValue": [
        "برای دریافت فقط یک مقدار از استیت، باید کلید متغیر را به عنوان آرگومان به متد `get` ارسال کنید.",
        "برای مثال، فرض کنید مقدار `foo` در استیت برابر با `'bar'` باشد. در این حالت می توانید مقدار `foo` را دریافت کرده و به صورت زیر به متغیری اختصاص دهید:"
      ],
      "multipleValues": [
        "اگر می خواهید بیش از یک مقدار را از استیت دریافت کنید، باید کلیدهای مورد نظر را به عنوان یک آرایه به متد `get` ارسال کنید. در این حالت مقدار برگشتی از متد `get` یک `آبجکت`  میباشد.",
        "برای مثال، فرض کنید استیت ما حاوی مقادیر `foo` برابر با `'bar'` و `baz` برابر با `'qux'` باشد. برای بازیابی همزمان مقادیر `foo` و `baz` می توانید از کد زیر استفاده کنید:"
      ],
      "explain": "همچنین در نظر داشته باشید که می توانید مانند مثال زیر مقادیر  شیء برگشتی را استخراج کنید تا هر مقدار را به یک متغیر جداگانه اختصاص دهید:"
    },
    "set": {
      "description": [
        "متد `set` برای تغییر یا اضافه کردن یک یا چند مقدار در استیت استفاده می شود. هنگامی که یک مقدار در استیت با استفاده از متد `set` تغییر می‌کند، همه کامپوننت هایی که از آن مقدار استفاده می‌کنند `rerender` می‌شوند. با این حال، این امکان نیز وجود دارد که یک مقدار را به صورت بی صدا تغییر دهید، بدون اینکه کامپوننت هایی که از آن استفاده می کنند، `rerender` شوند .",
        "_**توجه داشته باشید** که اگر مقداری را به‌صورت بی‌صدا تنظیم کنید، و کامپوننتی  که از آن مقدار استفاده می‌کند، بعداً به دلایل دیگر `rerender`  شود، مقدار جدید از استیت دریافت می‌شود._"
      ],
      "demo": [
        "در این مثال، کامپوننت `DisplayTime` مقدار زمان را از استیت موجود در `observer` با استفاده از هوک `useObserver` دریافت می کند و آن را در یک پاراگراف نمایش می دهد.",
        "این کامپوننت همچنین شامل سه دکمه است که به کاربر امکان می دهد مقدار زمان را به روش های مختلف به روز کند. اولین دکمه متد `setTime` را برای به روز رسانی مقدار با استفاده از هوک `useObserver` فراخوانی می کند. دکمه دوم متد `observer.set` را فراخوانی می کند تا مقدار را مستقیماً در استیت موجود در `observer` به روز کند. دکمه سوم متد `observer.set` را با گزینه `silent` فراخوانی می‌کند تا مقدار را به‌طور بی‌صدا به‌روزرسانی کند، بدون اینکه هیچ کامپوننتی  که از مقدار زمان استفاده می‌کند را `rerender` کند."
      ]
    },
    "example": {
      "description": [
        "این کد یک مثال ساده و کاربردی از نحوه استفاده از متد های `get`  و `set` در `observer` است. استفاده از این متد ها به کاربر این اجازه را می دهد تا کامپوننت مودال را باز و بسته کند و آنها را در در سرتاسر برنامه نمایش دهد."
      ],
      "app": "کامپوننت `App` نقطه ورود برنامه است. آن شامل دکمه ای است که باعث ایجاد شدن یک مودال جدید میشود و کامپوننت `Modals` وظیفه `render` کردن تمامی مودال های باز را دارد. تابع `newModal` از `actions.ts` ایمپورت شده تا ایجاد شدن مودال جدید را مدیریت کند.",
      "modal": "کامپوننت `Modals` از هوک `useObserver` برای دریافت آرایه `modals` از استیت استفاده می کند، که داده ها را برای هر مدال باز نگه می دارد. با استفاده از تابع `map` میتوان تمامی مودال های موجود را توسط کامپوننت `Modal` نمایش داد . کامپوننت `Modal` مسئول رندر مدال ها با `title` ، `body` و یک دکمه `close` میباشد.",
      "actions": "فایل `action` دو تابع `newModal` و `closeModal` را export می کند. هر دوی این توابع از نمونه `observer` ارائه شده توسط کتابخانه Rosma برای بدست آوردن و تنظیم آرایه `modals`  در استیت سراسری استفاده می کنند. تابع `newModal` یک شی مودال جدید با `id` ، `title` و `body` منحصر به فرد ایجاد می کند و آن را به آرایه `modals` اضافه می کند. تابع `closeModal` مودال را با شناسه داده شده از آرایه `modals` فیلتر می کند."
    },
    "state": {
      "description": [
        "مقدار فعلی استیت را برمی‌گرداند.",
        "توجه داشته باشید که تغییر دادن استیت با استفاده از Observer.state، کامپوننت ها را ری رندر نمی‌کند یا listener ها را اجرا نمی‌کند."
      ]
    },
    "isValid": {
      "description": [
        "`observer.get` بررسی می کند که آیا کلید داده شده در استیت وجود دارد یا خیر. یک استرینگ به عنوان کلید دریافت می کند و تعیین می کند که آیا آن متغیر در استیت تعریف شده است یا خیر."
      ]
    },
    "subscribe": {
      "description": [
        "متد `subscribe` برای نظارت بر تغییرات در یک یا چند متغیر در استیت استفاده می شود. این متد به دو پارامتر ورودی نیاز دارد:",
        "1. کلید یا کلیدهای مورد نظر که می خواهید تغییراتشان را نظرات کنید.",
        "2. یک `listener` که با تغییر کلید یا کلیدهای مورد نظر اجرا می شود.",
        "این متد یک تابع `unsubscribe` را برمی‌گرداند و به شما امکان می‌دهد که در صورت نیاز نظرات بر تغییرات متغیر ها را غیر فعال کنید. بسته به نیاز شما می‌توان از این متد در داخل `useEffect` یا خارج از کامپوننت React استفاده کرد. اگر نیاز به نظارت بر تغییرات چندین متغیر به طور همزمان را دارید، می توانید آنها را به عنوان یک آرایه تعریف کنید و آن را به عنوان اولین پارامتر به متد `subscribe` ارسال کنید. البته توجه داشته باشید که در این حالت مقادیر مورد نظر به عنوان یک `object` به تابع `listener` ارسال می شود.",
        "در بخش های بعدی بیشتر در مورد `subscribe` صحبت خواهیم کرد."
      ],
      "demo": [
        "در این مثال `observer` و `useObserver` را از کتابخانه rosma ایمپورت کرده. سپس با فراخوانی `observer.subscribe` و ارسال نام متغیر `myVar` به عنوان پارامتر اول و تابع listener به عنوان پارامتر دوم، نظرات بر تغییرات متغیر `myVar` را شروع میکنیم.",
        "کامپوننت `ObserverTest` از `useObserver` برای دریافت تابع `setMyVar` استفاده می کند که می تواند برای به روز رسانی مقدار `myVar` فراخوانی شود. آن کامپوننت دکمه ای را ارائه می کند که با کلیک کردن روی آن، `setMyVar` را با یک شیء تاریخ جدید به عنوان آرگومان اجرا می کند. هنگامی که `myVar` تغییر می کند، تابع listener فراخوانی می شود و یک هشدار با مقدار به روز شده `myVar` نمایش داده می شود.",
        "اگر کاربر روی دکمه لغو اشتراک کلیک کند. متد لغو اشتراک اجرا می شود و تابع listener با تغییرات `myVar` دیگر فراخوانی نمی شود."
      ]
    },
    "keywords": [
      [
        "observer",
        "مقادیر استیت سراسری",
        "بروزرسانی استیت",
        "تظارت بر استیت",
        "multiple instances",
        "observer.get",
        "observer.set",
        "observer.isValid",
        "observer.subscribe",
        "دریافت مقادیر",
        "گرفتن یک مقدار",
        "گرفتن چند مقدار",
        "تغییر یا اضافه کردن مقدار",
        "بی‌صدا",
        "پیش نمایش",
        "کامپوننت مودال",
        "app.tsx",
        "modals.tsx"
      ]
    ]
  },
  "multipleObservers": {
    "description": [
      "در صورتی که برنامه ای در مقیاس بزرگ دارید، یا میخواهید استیت بخش های مختلف اپ خود را به صورت جداگانه مدیریت کنید، میتوانید از کلاس `Observer` نمونه هایی به همین منظور ایجاد کنید.",
      "برای این منظور باید کلاس `observer` را از `rosma` ایمپورت کرده با و استفاده از کلید واژه `new` یک نمونه از آن بسازید."
    ],
    "initialValues": "توجه داشته باشد که اگر برای هر استیت مقادیر اولیه ای در تظر دارید، میتوانید آن مقادیر را به constructor کلاس observer ارسال کنید.",
    "example": "همچنین برای اینکه هوک useObserver از observer شخصی شما استفاده کند میتوانید observer خود را به این صورت به useObserver ارسال کنید.",
    "useObserver": {
      "description": "برای اینکه پاس دادن `observer` به هوک `useObserver` را در سرتاسر آپ خود تکرار نکنید میتوانید مانند مثال زیر یکبار hook شخصی خود را اکسپورت کرده و در همه جای آپ آن را ایمپورت کنید.",
      "explain": [
        "این مثال نشان می دهد که چگونه می توان چندین نمونه از کلاس `Observer` را با استیت های اولیه مختلف با استفاده از کلمه کلیدی `new` ایجاد کرد. سه نمونه از مشاهده‌گر با نام‌های `UIObserver،` `authObserver` و `dataObserver` ایجاد می‌شوند. هر نمونه مقدار اولیه متفاوتی دارد که هر کدام در object جداگانه ای تعریف شده اند .",
        "علاوه بر ایجاد مشاهده گر ها، ما سه تابع، `useUIObserver`، `useAuthObserver` و `useDataObserver` را export می کنیم که از هوک `useObserver` برای دسترسی به `observer` های مربوطه در سراسر برنامه استفاده می کنند.",
        "این رویکرد می تواند به مدیریت وضعیت بخش های مختلف یک برنامه به طور جداگانه کمک کند. با داشتن `observer` های جداگانه، می توانید به راحتی وضعیت یک قسمت خاص از برنامه را بدون تأثیر بر وضعیت سایر قسمت ها تغییر دهید."
      ]
    },
    "observers": {
      "description": "برای خوانا تر شدن کد بهتر است همانند مثال زیر، `observer` های مربوط به هر بخش از آپ خود را در یک فایل جداگانه نگهداری کنید:",
      "note": "**توجه:** این مثال به منظور ارائه مفهومی از نحوه مدیریت وضعیت در یک برنامه ارائه شده است و فقط جنبه توضیحی دارد. به عنوان مثال، در بخش `دیتا` ، توصیه می‌شود از کتابخانه‌های تخصصی‌تری مانند `react-query` برای گرفتن و cache کردن داده‌ها استفاده کنید."
    },
    "keywords": [
      [
        "رزما",
        "ری اکت",
        "مشاهده‌گر",
        "useObserver",
        "چند مشاهده گر",
        "مشاهده گر سفارشی"
      ]
    ]
  },
  "subscribe": {
    "description": [
      "در <u>[بخش های قبل](/observer#observersubscribe)</u> در مورد متد `subscribe` توضیح دادیم. اما در این بخش کمی بیشتر به آن خواهیم پرداخت.",
      "در اکثر حالت ها ما نیاز داریم تا با تغییر کردن مقادیر استیت، یک ریرندر در کامپوننت ری اکت ما ایجاد شود. ولی در برخی مواقع نیاز میشود که بدون ایجاد کردن ری رندر اضافه، بخواهیم تغییرات یک مقدار را رصد کنیم. در این حالت میتوان از متد `subscribe` موجود در `observer` استفاده کرد.",
      "متد `subscribe` را میتوان در دو بخش مختلف از اپ استفاده کرد .",
      "1. خارج از کامپوننت ری اکت\n 2. داخل هوک useEffect در کامپوننت ری اکت .",
      "**توجه** داشته باشد که **نباید** از متد `subscribe` در داخل `بدنه` کامپوننت خود استفاده کنید. چون با این کار، به ازای هر rerender، یک بار به صورت جداگانه برای تغییرات مقادیر مورد نظر subscribe میکنید که خود باعث ایجاد سربار اضافه میشود."
    ],
    "outside": {
      "description": [
        "در این مثال، ما با استفاده از متد `observer.subscribe` تغییرات مقدار زمان را با یک تابع `listener` رصد می‌کنیم. عملکرد `listener` به سادگی یک alert را با زمان فعلی نمایش می دهد.",
        "تابع `Component` یک کامپوننت React است که از هوک `useObserver` برای دسترسی به مقدار `time` و `setTime` که به ترتیب برای دریافت و به روز رسانی مقدار زمان کاربرد دارد استفاده می کند.",
        "**توجه** داشته باشید که تابع `listener` قبل از رندر مجدد کامپوننت فراخوانی می شود."
      ]
    },
    "inside": {
      "description": [
        "**توجه** داشته باشید که برای نظارت در تغییرات استیت در داخل کامپوننت React، باید عملیات `subscribe` را در داخل هوک `useEffect` قرار دهیم.",
        "همچنین نکته مهم دیگر این است که متد `subscribe` تابعی را برای اتمام عملیات نظارت (`unsubscribe`) برمی گرداند که باید هنگام `unmount` شدن کامپوننت ما فراخوانی شود.",
        "در اینجا ما همان مثال قبلی را برای استفاده در این بخش بازنویسی کرده ایم:"
      ]
    },
    "multiple": {
      "description": "با استفاده از یک تابع `listener` می توانید تغییرات چندین مقدار را به صورت همزمان کنترل کنید. برای انجام این کار، به جای ارسال یک رشته به عنوان اولین پارامتر به متد `subscribe`، باید یک آرایه از رشته ها را ارسال کنید.",
      "explain": [
        "در این مثال، ما با ارسال یک آرایه حاوی نام مقادیر `random1` و `random2` به متد `subscribe`، تغییرات آن مقادیر را با استفاده از یک تابع به نام `listener` مشاهده میکنیم.",
        "سپس دو کامپوننت به نام های ، `Component1` و `Component2` را تعریف می کنیم که از هوک `useObserver` برای دسترسی به مقادیر فعلی `random1` و `random2` استفاده می کنند. هر کامپوننت همچنین دکمه ای را ارائه می دهد که با کلیک کردن روی آن ، مقدار مربوطه را با استفاده از تابع `setRandom1` یا `setRandom2` به روز می کند.",
        "در نهایت، ما هر دو `Component1` و `Component2` را در کامپوننت `App` رندر می‌کنیم، به طوری که تغییرات `random1` و `random2` توسط تابع `listener`  قابل نظارت است. "
      ]
    },
    "everything": {
      "description": "برای نظرات بر تغییرات برای همه مقادیر موجود در استیت، می توانید هنگام  subscribe از کلید `*` به جای آرایه ای از نام مقادیراستفاده کنید. این به شما امکان می دهد به تغییرات برای همه مقادیر موجود در استیت گوش دهید.",
      "explain": "در این مثال، ما از کلید `*` به عنوان اولین پارامتر متد subscribe برای گوش دادن به تغییرات در تمام مقادیر حالت استفاده می کنیم. تابع listener کل آبجکت  استیت را به عنوان آرگومان دریافت می کند و ما می توانیم آن به مقادیری که به آنها علاقه داریم دسترسی داشته باشیم."
    },
    "keywords": [
      [
        "رُزما",
        "observer",
        "useObserver",
        "استیت",
        "مدیریت استیت",
        "نظارت بر تغییرات استیت",
        "نظارت بر چند مقدار",
        "ری اکت",
        "کامپوننت",
        "ری رندر"
      ]
    ]
  },
  "withState": {
    "description": [
      "با استفاده از هوک `withState` می توانید کامپوننت خود را به استیت سراسری متصل کنید. این هوک دو پارامتر دریافت می کند:",
      "- اولین پارامتر همان کامپوننت ری اکت شما میباشد.\n- پارامتر دوم اختیاری است و زمانی استفاده می شود که می خواهید کامپوننت خود را به یک `observer` سفارشی متصل کنید.",
      "در اینجا مثالی از نحوه استفاده از هوک `withState` آورده شده است:"
    ],
    "example1": [
      "در این مثال، کامپوننت `CountNumbers` با هوک `withState` به استیت سراسری متصل شده است. پراپ های `number`  و `setNumber` به طور خودکار توسط این هوک در اختیار کامپوننت قرار می گیرند.",
      "اگر نیاز دارید پارامترهای دیگری غیر از مقادیر موجود در استیت را به کامپوننت خود منتقل کنید، می توانید خروجی `withState` را در یک متغیر ذخیره کرده و از آن به عنوان کامپوننت React استفاده کنید و مقادیر دلخواه مورد نیاز خود را به عنوان پراپ به آن کامپوننت ارسال کنید."
    ],
    "example2": "در این مثال، مقدار ComponentA از خروجی هوک withState گرفته شده، همانطور که مشاهده میشود این کامپوننت  پراپ اضافی strTime را می پذیرد. همچنین ComponentB در داخل خود ComponentA را رندر کرده و پراپ strTime را به آن ارسال می کند.",
    "customObserver": {
      "description": "در این مثال یک observer سفارشی به عنوان پارامتر دوم به هوک withState ارسال شده است :",
      "explain": "در این مثال یک کامپوننت ری اکت  با استفاده از هوک withState به یک observer سفارشی که در پارامتر دوم به هوک withState پاس داده شده متصل شده است و خروجی آن در متغیری به نام CountNumber ذخیره  و export  شده است."
    },
    "keywords": [
      [
        "withState",
        "استیت سراسری",
        "هوک",
        "useState",
        "React",
        "مشاهده‌گر سفارشی",
        "کامپوننت",
        "پارامتر",
        "پراپ",
        "مقادیر",
        "Observer",
        "CountNumber",
        "setNumber"
      ]
    ]
  },
  "Demo": "پیش نمایش",
  "Counter App": "برنامه شمارنده",
  "No Order for Variables": "امکان جابجایی متغیر ها",
  "Case Insensitive Variables": "حساس نبودن به حروف بزرگ و کوچک",
  "the count is": "مقدار count برابر است با ",
  "Setting different initial values": "تنظیم مقادیر اولیه مختلف",
  "Define initial values separately": "مقادیر اولیه را جداگانه تعریف کنید",
  "Define initial values at once": "مقادیر اولیه را به یکباره تعریف کنید",
  "Getting a Single Value": "دریافت یک مقدار",
  "Getting Multiple Values": "دریافت چند مقدار به صورت همزمان",
  "Modals Example": "یک مثال از کامپوننت مودال",
  "Separating observers": "جداسازی مشاهده گر ها",
  "Custom useObserver hook": "سفارشی کردن هوک useObserver",
  "UI part": "بخش UI",
  "Auth part": "بخش احراز هویت",
  "Data part": "بخش دیتا",
  "Subscribe": "نظارت بر تغییرات",
  "Subscribing outside the React component": "رصد تغییرات خارج از کامپوننت ری اکت",
  "Subscribing inside the React component": "رصد تغییرات داخل کامپوننت ری اکت",
  "subscribing for more than one value": "رصد تغییرات چند مقدار",
  "Subscribing for every state changes": "نظارت بر تمامی مقادیر",
  "Custom observer and withState": "observer سفارشی همراه با withState"
}
