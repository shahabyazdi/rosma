{
  "common": {
    "Rosma": "رُزما",
    "Next": "بعدی",
    "Previous": "قبلی",
    "Home": "خانه",
    "Installation": "نصب و راه اندازی",
    "en": "انگلیسی",
    "fa": "فارسی",
    "Keywords": "کلید واژه ها",
    "Usage": "استفاده",
    "Multiple destructuring": "گرفتن همزمان چندین متغیر",
    "Different initial values": "مقادیر اولیه متفاوت"
  },
  "home": {
    "description": [
      "Rosma یک کتابخانه مدیریت  سراسری استیت کم حجم و با استفاده آسان است که برای کامپوننت های ری اکت طراحی شده است. رزما سه API ضروری برای مدیریت وضعیت برنامه به شما ارائه می دهد: `observer` ، `useObserver`، و `withState`.",
      "برخلاف سایر کتابخانه های مدیریت استیت، راه اندازی و استفاده از Rosma فوق العاده آسان است و به گونه ای نوشته شده است که نیازی به تنظیمات اولیه و گاه پیچیده ندارد. به سادگی آن را از طریق ان پی ام (`npm i rosma`) نصب کنید و بدون کانفیگ اضافه، استفاده از آن را شروع کنید.",
      "یکی از مزایای کلیدی Rosma، نامگذاری ساده آن برای متغیرها و متدهای ستر برای متغیر ها است. برای تعریف کردن یک ستر متد برای یک متغیر، تنها کاری که باید انجام دهید این است که قبل از نام متغیر یک `set` اضافه کنید و آن را استخراج کنید. به عنوان مثال، برای تنظیم یک مقدار برای متغیر `count`، باید ستر متد مربوطه را `setCount` نامگذاری کنید.",
      "ای پی ای `observer` در رزما به شما این امکان را می دهد که با آن متغیرهای استیت سراسری را تعریف کرده  و آنها را از هر جایی در برنامه خود فراخوانی یا بروزرسانی کنید. `useObserver` یک هوک ساده برای استفاده از متغیرهای موجود در استیت، در کامپوننت ها شما ارائه می‌کند، در حالی که `withState` یک higher order component است که کامپوننت های شما را به استیت سراسری متصل میکند.",
      "به طور کلی، Rosma یک کتابخانه مدیریت استیت قدرتمند و در عین حال ساده است که فرآیند مدیریت وضعیت برنامه شما را ساده می کند. امروز آن را امتحان کنید و ببینید که چگونه می تواند روند توسعه برنامه های شما را بهبود بخشد."
    ],
    "keywords": [
      [
        "ری اکت",
        "مدیریت استیت",
        "استیت سراسری",
        "مشاهده کننده",
        "useObserver",
        "withState",
        "lightweight",
        "نصب آسان",
        "کاربر پسند",
        "npm",
        "نامگذاری",
        "متد تنظیم استیت",
        "فانکشنال کامپوننت",
        "روند کار توسعه"
      ]
    ]
  },
  "installation": {
    "howto": "برای نصب Rosma می‌توانید از `npm` یا `yarn` استفاده کنید. به سادگی دستور زیر را در پوشه پروژه خود اجرا کنید:",
    "description": [
      "با این کار آخرین نسخه کتابخانه از رجیستری npm دانلود و نصب می شود.",
      "پس از نصب، می توانید سه API اصلی (`observer`، `useObserver` و `withState`) را از بسته `rosma` ایمپورت کرده و مدیریت استیت برنامه خود را شروع کنید.",
      "مهم است که توجه داشته باشید که Rosma به هیچ گونه تنظیمات یا پیکربندی اضافی نیاز ندارد، و آن را به یک انتخاب ایده آل برای توسعه دهندگانی تبدیل می کند که به دنبال راه حل مدیریت استیت ساده و آسان هستند."
    ],
    "keywords": [
      [
        "ری اکت",
        "مدیریت استیت",
        "نصب",
        "npm",
        "استیت سراسری",
        "observer",
        "useObserver",
        "withState",
        "کم حجم",
        "آسان",
        "تنظیمات",
        "قواعد نامگذاری",
        "کامپوننت",
        "روند توسعه"
      ]
    ]
  },
  "usage": {
    "counter": {
      "description": "کامپوننت `Counter` یک مثال ساده است که نحوه استفاده از Rosma را برای مدیریت استیت در برنامه React نشان می دهد. در این مثال از `useObserver` برای ایجاد یک متغیر سراسری به نام `count` با مقدار اولیه `۰` و یک متد setter به نام `setCount` استفاده می کنیم.",
      "alt": "میتوان همین مثال بالا را با استفاده از `withState` به صورت زیر بازنویسی کرد :",
      "explain": [
        "در مثال بالا، ما از هوک `useObserver`  برای ایجاد یک متغیر سراسری به نام `count`  استفاده کرده و متد تنظیم کننده مربوط به آن را `setCount`  نام گذاری می‌کنیم. مقدار اولیه `count` روی `۰`  تنظیم شده است.",
        "برای به‌روزرسانی متغیر `count`، به سادگی متد تنظیم‌کننده مربوطه آن  `setCount`  را با مقدار جدید صدا میزنیم. در این مورد، هر بار که روی دکمه کلیک می‌شود، مقدار `count`  را با `۱` جمع میکنیم."
      ]
    },
    "order": {
      "description": "شایان ذکر است که ترتیب گرفتن متغیرها از هوک `useObserver` مهم نیست. رزما به طور خودکار مقادیر صحیح را به هر متغیر بر اساس نام آنها اختصاص می دهد.",
      "explain": "در مثال بالا، ما متغیرهای `setCount` و `count` را به ترتیبی خلاف مثال قبلی دریافت کردیم و Rosma همچنان می‌تواند مقادیر صحیح را به هر متغیر اختصاص دهد."
    },
    "caseinsensitive": {
      "description": "همچنین مهم است که توجه داشته باشید که نام‌ همه متغیر ها در استیت به حروف بزرگ و کوچک حساس نیستند. این بدان معنی است که شما می توانید هر ترکیبی از حروف بزرگ و کوچک را درهنگام گرفتن متغیرهای خود از `useObserver`  استفاده کنید.",
      "explain": [
        "در مثال بالا، ما متغیر `count` را به عنوان `CouNt` و method  تنظیم کننده متناظر آن را به عنوان `setcOunT` نامگذاری کردیم، هر دو با حروف کوچک و بزرگ ترکیبی. رزما هنوز هم قادر است مقادیر صحیح را به هر متغیر بر اساس نام آنها اختصاص دهد."
      ]
    },
    "keywords": [
      [
        "ری اکت",
        "مدیریت استیت",
        "رُزما",
        "useObserver",
        "استیت سراسری",
        "نامگذاری مقادیر",
        "استخراج مقادیر",
        "متد تنظیم کننده",
        "حساس نبودن به حروف",
        "قواعد نامگذاری"
      ]
    ]
  },
  "multipleDestructuring": {
    "description": [
      "در Rosma، شما به راحتی می توانید چندین متغیر را به طور همزمان از هوک `useObserver` دریافت کنید. این می تواند کد شما را مختصرتر و خواناتر کند.",
      "به مثال زیر توجه کنید:"
    ],
    "explain": "در کد بالا، ما به طور همزمان متغیرهای `count1`، `setCount`، `count` و `setCount1` را از هوک `useObserver` دریافت کردیم. این به ما این امکان را می دهد که مستقیماً این متغیرها را در کامپوننت خود، بدون نیاز به دسترسی به `observer` استفاده کنیم.",
    "keywords": [
      [
        "رُزما",
        "observer",
        "useObserver",
        "دریافت مقادیر",
        "مدیریت استیت",
        "توسعه فرانت اند",
        "بهینه سازی کد",
        "خوانایی کد",
        "هوک ری اکت",
        "مقادیر چند گانه",
        "مقدار دهی متغیر"
      ]
    ]
  },
  "initialValues": {
    "description": "به‌طور پیش‌فرض، همه متغیرهای گرفته شده از `useObserver` مقادیر اولیه یکسانی دارند. برای تنظیم مقادیر اولیه متفاوت برای هر متغیر، میتونید از یکی از روش های زیر استفاده کنید:",
    "separate": {
      "explain": "در کد بالا، هوک `useObserver` را دوبار و به صورت جداگانه برای تعریف مقادیر اولیه مختلف برای `count` و `count1` استفاده کردیم."
    },
    "once": {
      "description": "اگر می خواهید مقادیر اولیه را برای همه متغیرها به طور همزمان تنظیم کنید، می توانید قبل از فراخوانی هوک `useObserver` آنها را مستقیما و با استفاده از متد `set`  موجود در `observer` استفاده کنید:",
      "explain": [
        "در کد بالا، قبل از فراخوانی هوک `useObserver` ، مقادیر اولیه `count` و `count1` را با استفاده از `observer.set` تنظیم می‌کنیم. این به ما امکان می‌دهد که متغیرها را بدون ارسال هیچونه آرگومان به هوک `useObserver` مقداردهی و استفاده کنیم، و آن متغیرها مقادیر اولیه‌ای را خواهند داشت که با استفاده از `observer.set` مشخص کردیم.",
        "به طور کلی، گرفتن چندین متغیر از `useObserver` می‌تواند به مختصر و خوانا تر شدن کد شما کمک کند، و تنظیم مقادیر اولیه متفاوت برای هر متغیر با استفاده از روش‌هایی که در بالا توضیح داده شد، آسان است."
      ]
    },
    "keywords": [
      [
        "رزما",
        "useObserver",
        "دریافت مقادیر",
        "مقادیر اولیه",
        "observer.set",
        "هوک های ری اکت",
        "بهینه سازی کد",
        "خوانایی کد",
        "مدیریت استیت",
        "برنامه نویسی فرانت اند"
      ]
    ]
  },
  "observer": {
    "description": [
      "Observer ابزاری است که به شما امکان می دهد متغیرهای استیت سراسری خود را مقداردهی کرده و آنها را از هر نقطه در برنامه خود به روز کنید.",
      "با استفاده از Observer، علاوه بر به روز رسانی مقادیر استیت، می توانید به تغییرات مقادیر گوش دهید تا در صورت تغییر آنها  از آن مطلع شوید.",
      "به طور پیش فرض، Rosma از یک نمونه از کلاس Observer استفاده می کند. با این حال، می توانید از چندین نمونه از کلاس Observer برای مدیریت بهتر پروژه خود استفاده کنید. در بخش های بعدی این موضوع توضیح داده خواهد شد.",
      "کلاس Observer چندین متد ارائه می دهد که در زیر لیست شده است:",
      "- observer.get \n- observer.set \n- observer.isValid \n- observer.subscribe"
    ],
    "get": {
      "description": "متد `observer.get` برای دریافت مقادیر از استیت استفاده می شود. می توانید از این متد برای دریافت یک یا چند مقدار به طور همزمان استفاده کنید.",
      "singleValue": [
        "برای دریافت فقط یک مقدار از استیت، باید کلید متغیر را به عنوان آرگومان به متد `get` ارسال کنید.",
        "برای مثال، فرض کنید مقدار `foo` در استیت برابر با `'bar'` باشد. در این حالت می توانید مقدار `foo` را دریافت کرده و به صورت زیر به متغیری اختصاص دهید:"
      ],
      "multipleValues": [
        "اگر می خواهید بیش از یک مقدار را از استیت دریافت کنید، باید کلیدهای مورد نظر را به عنوان یک آرایه به متد `get` ارسال کنید. در این حالت مقدار برگشتی از متد `get` یک `آبجکت`  میباشد.",
        "برای مثال، فرض کنید استیت ما حاوی مقادیر `foo` برابر با `'bar'` و `baz` برابر با `'qux'` باشد. برای بازیابی همزمان مقادیر `foo` و `baz` می توانید از کد زیر استفاده کنید:"
      ],
      "explain": "همچنین در نظر داشته باشید که می توانید مانند مثال زیر مقادیر  شیء برگشتی را استخراج کنید تا هر مقدار را به یک متغیر جداگانه اختصاص دهید:"
    },
    "set": {
      "description": [
        "متد `set` برای تغییر یا اضافه کردن یک یا چند مقدار در استیت استفاده می شود. هنگامی که یک مقدار در استیت با استفاده از متد `set` تغییر می‌کند، همه کامپوننت هایی که از آن مقدار استفاده می‌کنند `rerender` می‌شوند. با این حال، این امکان نیز وجود دارد که یک مقدار را به صورت بی صدا تغییر دهید، بدون اینکه کامپوننت هایی که از آن استفاده می کنند، `rerender` شوند .",
        "_**توجه داشته باشید** که اگر مقداری را به‌صورت بی‌صدا تنظیم کنید، و کامپوننتی  که از آن مقدار استفاده می‌کند، بعداً به دلایل دیگر `rerender`  شود، مقدار جدید از استیت دریافت می‌شود._"
      ],
      "demo": [
        "در این مثال، کامپوننت `DisplayTime` مقدار زمان را از استیت موجود در `observer` با استفاده از هوک `useObserver` دریافت می کند و آن را در یک پاراگراف نمایش می دهد.",
        "این کامپوننت همچنین شامل سه دکمه است که به کاربر امکان می دهد مقدار زمان را به روش های مختلف به روز کند. اولین دکمه متد `setTime` را برای به روز رسانی مقدار با استفاده از هوک `useObserver` فراخوانی می کند. دکمه دوم متد `observer.set` را فراخوانی می کند تا مقدار را مستقیماً در استیت موجود در `observer` به روز کند. دکمه سوم متد `observer.set` را با گزینه `silent` فراخوانی می‌کند تا مقدار را به‌طور بی‌صدا به‌روزرسانی کند، بدون اینکه هیچ کامپوننتی  که از مقدار زمان استفاده می‌کند را `rerender` کند."
      ]
    },
    "example": {
      "description": [
        "این کد یک مثال ساده و کاربردی از نحوه استفاده از متد های `get`  و `set` در `observer` است. استفاده از این متد ها به کاربر این اجازه را می دهد تا کامپوننت مودال را باز و بسته کند و آنها را در در سرتاسر برنامه نمایش دهد."
      ],
      "app": "کامپوننت `App` نقطه ورود برنامه است. آن شامل دکمه ای است که باعث ایجاد شدن یک مودال جدید میشود و کامپوننت `Modals` وظیفه `render` کردن تمامی مودال های باز را دارد. تابع `newModal` از `actions.ts` ایمپورت شده تا ایجاد شدن مودال جدید را مدیریت کند.",
      "modal": "کامپوننت `Modals` از هوک `useObserver` برای دریافت آرایه `modals` از استیت استفاده می کند، که داده ها را برای هر مدال باز نگه می دارد. با استفاده از تابع `map` میتوان تمامی مودال های موجود را توسط کامپوننت `Modal` نمایش داد . کامپوننت `Modal` مسئول رندر مدال ها با `title` ، `body` و یک دکمه `close` میباشد.",
      "actions": "فایل `action` دو تابع `newModal` و `closeModal` را export می کند. هر دوی این توابع از نمونه `observer` ارائه شده توسط کتابخانه Rosma برای بدست آوردن و تنظیم آرایه `modals`  در استیت سراسری استفاده می کنند. تابع `newModal` یک شی مودال جدید با `id` ، `title` و `body` منحصر به فرد ایجاد می کند و آن را به آرایه `modals` اضافه می کند. تابع `closeModal` مودال را با شناسه داده شده از آرایه `modals` فیلتر می کند."
    },
    "isValid": {
      "description": [
        "`observer.get` بررسی می کند که آیا کلید داده شده در استیت وجود دارد یا خیر. یک استرینگ به عنوان کلید دریافت می کند و تعیین می کند که آیا آن متغیر در استیت تعریف شده است یا خیر."
      ]
    },
    "subscribe": {
      "description": [
        "متد `subscribe` برای نظارت بر تغییرات در یک یا چند متغیر در استیت استفاده می شود. این متد به دو پارامتر ورودی نیاز دارد:",
        "1. کلید یا کلیدهای مورد نظر که می خواهید تغییراتشان را نظرات کنید.",
        "2. یک `listener` که با تغییر کلید یا کلیدهای مورد نظر اجرا می شود.",
        "این متد یک تابع `unsubscribe` را برمی‌گرداند و به شما امکان می‌دهد که در صورت نیاز نظرات بر تغییرات متغیر ها را غیر فعال کنید. بسته به نیاز شما می‌توان از این متد در داخل `useEffect` یا خارج از کامپوننت React استفاده کرد. اگر نیاز به نظارت بر تغییرات چندین متغیر به طور همزمان را دارید، می توانید آنها را به عنوان یک آرایه تعریف کنید و آن را به عنوان اولین پارامتر به متد `subscribe` ارسال کنید. البته توجه داشته باشید که در این حالت مقادیر مورد نظر به عنوان یک `object` به تابع `listener` ارسال می شود.",
        "در بخش های بعدی بیشتر در مورد `subscribe` صحبت خواهیم کرد."
      ],
      "demo": [
        "در این مثال `observer` و `useObserver` را از کتابخانه rosma ایمپورت کرده. سپس با فراخوانی `observer.subscribe` و ارسال نام متغیر `myVar` به عنوان پارامتر اول و تابع listener به عنوان پارامتر دوم، نظرات بر تغیرات متغیر `myVar` را شروع میکنیم.",
        "کامپوننت `ObserverTest` از `useObserver` برای دریافت تابع `setMyVar` استفاده می کند که می تواند برای به روز رسانی مقدار `myVar` فراخوانی شود. آن کامپوننت دکمه ای را ارائه می کند که با کلیک کردن روی آن، `setMyVar` را با یک شیء تاریخ جدید به عنوان آرگومان اجرا می کند. هنگامی که `myVar` تغییر می کند، تابع listener فراخوانی می شود و یک هشدار با مقدار به روز شده `myVar` نمایش داده می شود.",
        "اگر کاربر روی دکمه لغو اشتراک کلیک کند. متد لغو اشتراک اجرا می شود و تابع listener با تغییرات `myVar` دیگر فراخوانی نمی شود."
      ]
    },
    "keywords": [
      [
        "observer",
        "مقادیر استیت سراسری",
        "بروزرسانی استیت",
        "تظارت بر استیت",
        "multiple instances",
        "observer.get",
        "observer.set",
        "observer.isValid",
        "observer.subscribe",
        "دریافت مقادیر",
        "گرفتن یک مقدار",
        "گرفتن چند مقدار",
        "تغییر یا اضافه کردن مقدار",
        "بی‌صدا",
        "پیش نمایش",
        "کامپوننت مودال",
        "app.tsx",
        "modals.tsx"
      ]
    ]
  },
  "Demo": "پیش نمایش",
  "Counter App": "برنامه شمارنده",
  "No Order for Variables": "امکان جابجایی متغیر ها",
  "Case Insensitive Variables": "حساس نبودن به حروف بزرگ و کوچک",
  "the count is": "مقدار count برابر است با ",
  "Setting different initial values": "تنظیم مقادیر اولیه مختلف",
  "Define initial values separately": "مقادیر اولیه را جداگانه تعریف کنید",
  "Define initial values at once": "مقادیر اولیه را به یکباره تعریف کنید",
  "Getting a Single Value": "دریافت یک مقدار",
  "Getting Multiple Values": "دریافت چند مقدار به صورت همزمان",
  "Modals Example": "یک مثال از کامپوننت مودال"
}
